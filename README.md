# Eye

![Eye Logo](https://github.com/tailogs/Eye/assets/69743960/238ea7db-d4a2-4969-a4bc-115133a571a8)

Eye - это простой интерпретируемый язык программирования, разработанный в рамках проекта для изучения компиляторных технологий. Eye преимущественно ориентирован на объектно-ориентированное программирование, но также включает элементы функционального программирования.

## Цель языка

Я хотел бы реализовать язык программирования, которая будет перекладывать большую часть работы на виртуальную машину, а сам по себе будет давать достаточно свободы для реализации своих проектов.
В нем будет возможность писать короткий и читабельный подобно тому, как это реализуется в `Python`, но понимать важность порой быть загроможденным точными вещами как в языке `Java`. 
Этот язык будет стримиться не за размером исполняемого файла, экономии памяти и скоростью работы программы, а за удобством, но не более того как в языке `Haskell`.
Данный язык игнорирует явное указание типов при создании переменной и возврате значения из функции и дабы облегчить проблему возникающую из-за этого язык будет стримиться постепенно прийти к общирным ответам об ошибках как в языке `Java` и `Rust`, и конечно же избегать ошибок которые показываются в `C/C++`.
Но самое главное это динамичность развитии языка. Он не будет стоять на месте и будет изменяться, пускай даже во вред обратной совместимости, но он будет становиться постепенно лучше. Возможно даже координально меняясь.
Помните, что это пока язык одного разработчика для самого себя, но если он вам понравиться, то вы можете его использовать как только вашей душе угодно по доступной лицензии указанной в конце файла `README.md` и в исходном коде проекта.

## Установка

1. **Клонировать репозиторий:**

   ```bash
   git clone https://github.com/tailogs/Eye.git
   ```

   ```bash
   cd Eye
   ```

2. **Запуск примера:**

   ```bash
   python3 Eye.py
   ```

## Возможности

- **Переменные:** поддерживаются переменные типов: числа `int` и `float`, строки `string`, булевы значения `true` и `false`.
- **Функции:** можно определять функции с произвольным числом аргументов и возвращаемым значением.
- **Арифметические операции:** поддерживаются операции сложения `+`, вычитания `-`, умножения `*` и деления `/`, целочисленного деления `//`, остатка от деления `%`.
- **Вывод на экран:** доступна функция `print` и `println` для вывода значений на экран.
- **Условные операторы:** доступны условные операторы `if`, `else`, `ifel (аналог elif)` для выполнения условных проверок и ветвлений в коде. 
- **Цикл** в языке присутствует цикл `while`.
- **Комментарии** в языке существуют однострочные комментарии начинающиеся с символа `~` и могут размещаться после конца строки кода, но после символа `;` или же на отдельной строке.
- **Массивы:** поддерживаются динамические массивы для хранения упорядоченных коллекций разного типа данных.

## Синтаксис

### Переменные

```eye
let x = 10;
let s = "Hello, world!";
let b = true;
```

### Функции

```eye
fn add(a, b) {
    return a + b;
}
```

### Вызов функций

```eye
let y = add(x, 20);
```

### Вывод на экран

```eye
print(y); ~ выводит значение y без перехода на новую строку
println(y); `~` выводить значение y и переходит на новую строку
```

### Условные операторы

```eye
if (x > 11) {
    println("x больше 0");
}


if (x < 20) {
    println("x меньше 20");
} else {
    println("x не меньше 20");
}

if (x > 5) {
    println("x больше 5");
} ifel (x > 15) {
    println("x больше 15");
} else {
    println("x равен 5 или меньше");
}
```

### Цикл

```eye
let x = 10;
while (x > 0) {
    println(x);
    let x = x - 1;
}
```

### Массив

```eye
let array = [1, 2, 3, 4, 5]; ~ Создание массива

println("Массив: " + array);
println("Элемент массива с индексом 2: " + get_element(array, 2));  ~ Должно вывести "3"
set_element(array, 2, 99);
println("Обновленный массив: " + array);  ~ Должно вывести "[1, 2, 99, 4, 5]"
remove_element(array, 3);
println("Массив после удаления элемента с индексом 3: " + array);  ~ Должно вывести "[1, 2, 99, 5]"
append_element(array, 6);
println("Массив после добавления элемента 6: " + array);  ~ Должно вывести "[1, 2, 99, 5, 6]"
```

### Строки

```eye
let str1 = "Привет";
let str2 = "Мир";

println("Конкатенация: " + (str1 + " " + str2));  ~ Должно вывести "Конкатенация: Привет Мир"

let substr = substring((str1 + ", " + str2), 7);
println("Подстрока: " + substr);  ~ Должно вывести "Подстрока: Мир"

let length1 = length(str1);
let length2 = length(str2);
println("Длины строк: " + to_string(length1) + ", " + to_string(length2));  ~ Должно вывести "Длины строк: 6, 3"

if (str1 == "Привет") {
    println("Сравнение строк: Равны");
} else {
    println("Сравнение строк: Не равны");
}

if (compare_strings(str2, str1) > 0) {
    println("Сравнение строк: str2 больше str1");
} else {
    println("Сравнение строк: str2 не больше str1");
}
```

### Функции для работы с массивами

#### `get_element(array, index)`
Получает элемент из массива по указанному индексу.

#### `set_element(array, index, value)`
Устанавливает значение элемента в массиве по указанному индексу.

#### `remove_element(array, index)`
Удаляет элемент из массива по указанному индексу и возвращает его.

#### `append_element(array, value)`
Добавляет значение в конец массива.

#### `get_range(array, start, end)`
Возвращает подмассив, начиная с индекса `start` до `end-1`.


### Функции для работы со строками

#### `substring(string, start, end=None)`
Возвращает подстроку строки, начиная с индекса `start` до `end-1`.

#### `string_length(string)`
Возвращает длину строки.

#### `compare_strings(str1, str2)`
Сравнивает две строки и возвращает `-1`, `0` или `1` в зависимости от того, меньше ли `str1`, равны ли они, или больше ли `str1` по алфавиту.

#### `find_substring(string, substring)`
Находит первое вхождение подстроки `substring` в строку `string` и возвращает его индекс. Если подстрока не найдена, возвращает `-1`.

#### `get_char_at(string, index)`
Возвращает символ строки `string` по указанному индексу `index`.

#### `to_uppercase(string)`
Преобразует строку в верхний регистр.

#### `to_lowercase(string)`
Преобразует строку в нижний регистр.

#### `replace_substring(string, old_substring, new_substring)`
Заменяет все вхождения `old_substring` в строку `string` на `new_substring`.

#### `split_string(string, delimiter=None)`
Разбивает строку `string` на список подстрок по разделителю `delimiter`. Если `delimiter` не указан, разбивает по пробелам.


### Функции для работы с другими типами данных

#### `length(value)`
Возвращает длину строки, массива, числа и булевого значения.

#### `to_string(value)`
Преобразует значение в строку.

#### `to_integer(value)`
Преобразует значение в целое число.

#### `to_float(value)`
Преобразует значение в число с плавающей запятой.

#### `to_boolean(value)`
Преобразует значение в логическое (булево) значение.


### Функции для работы с памятью

#### `delete(value)`
Позволяет удалить заранее любую переменную которую ранее создавали до того, как оно будет удалено виртуальной машиной.

> Эти функции позволяют манипулировать различными типами данных упрощая работу с массивами, строками, числами и булевыми значениями.


## Примеры

### Факториал

```eye
~ Определяем функцию factorial для вычисления факториала числа n
fn factorial(n) {
    if (n == 0) {
        return 1; ~ Если n равно 0, возвращаем 1 (базовый случай рекурсии)
    } else {
        return n * factorial(n - 1); ~ Иначе возвращаем произведение n на факториал (n - 1) (рекурсивный случай)
    }
}

let num = 5; ~ Определяем переменную num и присваиваем ей значение 5

let result = factorial(num); ~ Вызываем функцию factorial с аргументом num и сохраняем результат в переменную result

println("Факториал числа " + num + " равен: " + result); ~ Выводим на экран сообщение о значении факториала числа num
```

## Что планируется в будущем

Eye находится в стадии активной разработки, и разработчики планируют внедрить следующие возможности:

- **Массивы:** Упростить работу с массивами, например, извлечение, изменение, добавление, удаление элементов и все другие операции присущие массивам.

- **Циклы:** Реализация циклов `do while` и `for` для многократного выполнения блоков кода в зависимости от условий или количества итераций.

- **Функции высшего порядка:** Возможность создания функций, которые принимают другие функции в качестве аргументов или возвращают их как результат.

- **Стандартная библиотека:** Разработка стандартной библиотеки функций и утилит для общих задач программирования, таких как работа со строками, математические операции и управление файлами и т.д.

- **Обработка ошибок:** Улучшение системы обработки ошибок для предоставления более информативных и полезных сообщений об ошибках.

- **Модульная система:** Введение модульной системы для организации кода на более крупном масштабе, позволяющая лучше структурировать проекты и повторно использовать код.

- **Оптимизации интерпретатора:** Улучшение производительности выполнения кода через оптимизацию.

- **Интеграция с другими языками:** Разработка возможности интеграции Eye с другими языками программирования для улучшения совместимости и расширения возможностей разработки.

- **Компилирование** Переписать исходный код данного языка программирования на любой компилируемый язык программированя.

- **Самосборка** Переписать исходный код данного языка программирования на самого себя (возможно реализовать только после реализации пункта "Компилирование").

- **ООП** Реализация всех возможностей и трех главных принципов ООП.

- **Декларативность** Реализовать некоторые из возможностей функциональных языков, но не более того.

- **Явные примеры** Разработать примеры демонстрирующие все возможности языка программирования.

- **Проекты** Разработать несколько проектов на этом языке программирования.

- **Общирная документация** Улучшить документацию интегрированную в `README.md` файл и создать отдельную её версию. В документации должны быть подробно описаны все функции и элементы языка программирования.

- **Библиотеки** Реализовать возможность создания и подключения сторонних библиотек. По возможности создать пакетный менеджер.

- **Сообщество** Развить сообщество разработчиков и пользователей которые будут использовать и по желанию вносить корректировки в язык программирования. Создать тематические каналы, группы и т.д.

- **Экосистема** Языку программирования всегда требуется своя развитая экосистема.

- **Официальный сайт** Сайт которые будет выступать лицом данного языка программирования и которая будет упрощать его скачивания неопытным пользователям.

- **Читабельность** Повысить читабельность и красоту исходного кода языка программирования, а так же его документирование комментариями.

- **Безопасность** Огородить программиста от большинства типовых ошибок и дать возможность не заботиться о работе с памятью и всем остальным. Реализовать свою виртуальную машину следящую за всем.

- **Нет обратной совместимости** Я знаю что многие хотят реализовать свои языки с учетом этой концепции, но оно тормозит развитие языка и загромождает его. Нужно стараться следовать новому времени, а не топчаться на месте.

> Эти шаги направлены на постепенное расширение функциональности Eye, делая его более мощным и универсальным инструментом для создания программ.


## Зависимости

- Python 3.x

## Лицензия

[Apache License](LICENSE)

---

Этот README.md предоставляет общее представление о языке Eye, включая установку, возможности, примеры кода, планы на будущее и информацию о синтаксисе.